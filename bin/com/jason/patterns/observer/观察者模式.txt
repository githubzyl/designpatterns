设计模式之观察者模式
1、定义：
   定义对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
2、学习观察者模式通用代码
   1）目标对象的定义
   2）具体的目标对象的定义
   3）观察者的接口定义
   4）观察者的具体实现
3、认识观察者模式
   1）目标与观察者的关系
   2）单向依赖
   3）命名建议
   4）触发通知的时机
   5）观察者模式的调用顺序示意图
   6）通知的顺序
4、实现的两种方式：
   1）推模型
   	  A、目标对象主动向观察者推送目标的详细信息
   	  B、推送的数据通常是目标对象的全部或部分数据
   2）拉模型
      A、目标对象在通知观察者的时候只传递少量信息
      B、如果观察者需要更具体的信息，由观察者主动到目标对象中获取，相当于是观察者从目标对象中拉数据；
         一般这种模型的实现中，会把目标对象自身通过update方法传递给观察者。
5、推模型和拉模型的比较
   1）推模型是假定目标对象知道观察者需要的数据；
      拉模型是目标对象不知道观察者具体需要什么数据，因此把自身传给观察者，由观察者来取值。
   2）推模型会使观察者对象难以复用；
      拉模型下，update方法的参数是目标对象本身，基本上可以适应各种情况的需要。
6、利用java提供的观察者实现
   包：java.util
   目标对象：Observable
   观察者接口：Observer
   方法：update()
   java实现与自己实现的对比：
       1）不需要再定义观察者和目标接口了，JDK已经帮忙定义了
       2）具体的目标实现里面不需要维护观察者的注册信息了，这个在Java中的Observable类里面已经帮忙实现好了。
       3）触发通知的方式有一点变化，要先调用setChanged方法，这个是Java为了帮助实现更精确的触发控制而提供的功能。
       4）具体观察者的实现里面，update方法其实能同时支持推模型和拉模型，这个是Java定义的时候，就已经考虑进去了。
7、观察者模式的优缺点：
   优点：
   	   1）实现了观察者和目标之间的抽象耦合
       2）实现了动态联动
       3）支持广播通信
   缺点：
       1）可能引起无谓的操作，比如误更新
       2）可能引起资源损耗，性能降低
8、观察者模式的应用：
   1）观察者模式的本质：触发联动
   2）应用场景：
      A、当一个抽象模型有两个方面，其中一个方面的操作依赖于另一个方面的状态变化
      B、如果在更改一个对象的时候，需要同时连带改变其他对象，而且不知道究竟应该有多少个对象需要被连带改变
      C、当一个对象必须通知其他的对象，但是你又希望这个对象和其他被通知的对象是松散耦合的